// Generated by CoffeeScript 1.11.1
(function() {
  var App, diffLines, div, dmp, input, isTrivialChange, label, pre, ref, span, splitLines, textarea, vectorReduce,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = React.DOM, div = ref.div, textarea = ref.textarea, span = ref.span, pre = ref.pre, input = ref.input, label = ref.label;

  dmp = new diff_match_patch;

  diffLines = function(a, b) {
    var a1, a2, b1, b2, blocks, chars, chars1, chars2, j, len, len1, lineArray, op, push, ref1, ref2, ref3;
    ref1 = dmp.diff_linesToChars_(a, b), chars1 = ref1.chars1, chars2 = ref1.chars2, lineArray = ref1.lineArray;
    blocks = [];
    a1 = a2 = b1 = b2 = 0;
    push = function(len) {
      if (a1 !== a2 || b1 !== b2) {
        blocks.push([a1, a2, b1, b2]);
      }
      a1 = a2 = a2 + len;
      return b1 = b2 = b2 + len;
    };
    ref2 = dmp.diff_main(chars1, chars2, false);
    for (j = 0, len1 = ref2.length; j < len1; j++) {
      ref3 = ref2[j], op = ref3[0], chars = ref3[1];
      len = chars.length;
      if (op === 0) {
        push(len);
      }
      if (op < 0) {
        a2 += len;
      }
      if (op > 0) {
        b2 += len;
      }
    }
    push(0);
    return blocks;
  };

  splitLines = function(s) {
    var nextPos, pos, result;
    pos = 0;
    result = [];
    while (pos < s.length) {
      nextPos = s.indexOf('\n', pos);
      if (nextPos === -1) {
        nextPos = s.length - 1;
      }
      result.push(s.slice(pos, +nextPos + 1 || 9e9));
      pos = nextPos + 1;
    }
    return result;
  };

  isTrivialChange = function(diffBlocks, annotated, rev) {
    var a1, a2, b1, b2, ref1;
    if (diffBlocks.length !== 1) {
      return false;
    }
    ref1 = diffBlocks[0], a1 = ref1[0], a2 = ref1[1], b1 = ref1[2], b2 = ref1[3];
    if (a2 - a1 !== 1 || b2 - b1 !== 1 || a1 !== b1) {
      return false;
    }
    return annotated.get(a1)[0] === rev;
  };

  vectorReduce = function(vec, f, init) {
    var i, j, ref1, result;
    result = init;
    for (i = j = 0, ref1 = vec.size(); 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
      result = f(result, vec.get(i));
    }
    return result;
  };

  App = (function(superClass) {
    extend(App, superClass);

    function App(props) {
      App.__super__.constructor.call(this, props);
      this.linelog = new MemLinelog;
      this.state = {
        lineMap: {},
        ctimeMap: {},
        content: '',
        showDeleted: false,
        showRev: null,
        autoCommit: true
      };
    }

    App.prototype.getAnnotated = function(rev) {
      if (this.lastAnnotatedRev !== rev) {
        this.linelog.annotate(rev);
        this.lastAnnotatedResult = this.linelog.getAnnotateResult();
        this.lastAnnotatedRev = rev;
      }
      return this.lastAnnotatedResult;
    };

    App.prototype.handleTextChange = function(e) {
      var a, a1, a2, annotated, b, b1, b2, bi, blines, blocks, ctimeMap, j, l, len1, lineMap, ref1, ref2, ref3, ref4, ref5, rev, trivial;
      if (!this.state.autoCommit) {
        return;
      }
      a = this.state.content;
      b = e.target.value;
      blines = splitLines(b);
      ref1 = this.state, ctimeMap = ref1.ctimeMap, lineMap = ref1.lineMap;
      rev = this.linelog.getMaxRev();
      annotated = this.getAnnotated(rev);
      blocks = diffLines(a, b);
      trivial = isTrivialChange(blocks, annotated, rev);
      if (trivial) {
        a1 = blocks[0][0];
        lineMap[annotated.get(a1).slice(0, 2)] = blines[a1];
      } else {
        rev += 1;
        ref2 = blocks.reverse();
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          ref3 = ref2[j], a1 = ref3[0], a2 = ref3[1], b1 = ref3[2], b2 = ref3[3];
          for (bi = l = ref4 = b1, ref5 = b2; ref4 <= ref5 ? l <= ref5 : l >= ref5; bi = ref4 <= ref5 ? ++l : --l) {
            lineMap[[rev, bi]] = blines[bi];
          }
          this.linelog.replaceLines(rev, a1, a2, b1, b2);
        }
      }
      ctimeMap[rev] = new Date();
      return this.setState({
        lineMap: lineMap,
        ctimeMap: ctimeMap,
        content: b
      });
    };

    App.prototype.handleShowDeletedChange = function(e) {
      return this.setState({
        showDeleted: e.target.checked
      });
    };

    App.prototype.handleShowRevChange = function(e) {
      var rev;
      rev = parseInt(e.target.value);
      if (rev === this.linelog.getMaxRev()) {
        rev = null;
      }
      return this.setState({
        showRev: rev
      });
    };

    App.prototype.handleAutoCommitChange = function(e) {
      var value;
      value = e.target.checked;
      return this.setState({
        autoCommit: value
      });
    };

    App.prototype.getShowRev = function() {
      var rev;
      rev = this.state.showRev;
      if (rev === null) {
        rev = this.linelog.getMaxRev();
      }
      return rev;
    };

    App.prototype.render = function() {
      return div({
        className: 'columns',
        style: {
          height: '100%'
        }
      }, div({
        className: 'column'
      }, textarea({
        id: 'editor',
        ref: 'editor',
        onChange: this.handleTextChange.bind(this)
      })), div({
        className: 'column'
      }, this.renderControls(), this.renderAnnotated()));
    };

    App.prototype.renderControls = function() {
      var maxRev, rev;
      maxRev = this.linelog.getMaxRev();
      rev = this.getShowRev();
      return div({
        className: 'level controls'
      }, label({
        className: 'checkbox level-left'
      }, input({
        className: 'level-item',
        type: 'checkbox',
        checked: this.state.autoCommit,
        onChange: this.handleAutoCommitChange.bind(this)
      }), span({
        className: 'level-item'
      }, 'Auto commit')), label({
        className: 'checkbox level-left'
      }, input({
        className: 'level-item',
        type: 'checkbox',
        checked: this.state.showDeleted,
        onChange: this.handleShowDeletedChange.bind(this)
      }), span({
        className: 'level-item'
      }, 'Show deleted lines')), label({
        className: 'range level-right'
      }, span({
        className: 'level-item'
      }, "Select revision (" + rev + ")"), input({
        className: 'level-item',
        type: 'range',
        value: rev,
        min: 0,
        max: maxRev,
        onChange: this.handleShowRevChange.bind(this)
      })));
    };

    App.prototype.renderAnnotated = function() {
      var annotated, color, deleted, i, info, isDeleted, j, k, lineSet, lines, m, maxRev, ref1, rev, rgb, rows;
      annotated = this.getAnnotated(this.getShowRev());
      maxRev = this.linelog.getMaxRev();
      if (this.state.showDeleted) {
        lines = this.linelog.getAllLines();
        lineSet = vectorReduce(annotated, (function(m, v) {
          m[v.slice(0, 2)] = 1;
          return m;
        }), {});
        isDeleted = function(k) {
          return !lineSet[k];
        };
      } else {
        lines = annotated;
        isDeleted = function(k) {
          return false;
        };
      }
      rows = [];
      for (i = j = 0, ref1 = lines.size(); 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        info = lines.get(i);
        k = info.slice(0, 2);
        rev = k[0];
        m = moment(this.state.ctimeMap[rev]);
        deleted = isDeleted(k);
        if (deleted) {
          rgb = '140, 140, 140';
        } else {
          rgb = '78, 154, 6';
        }
        color = "rgba(" + rgb + ", " + (rev / maxRev) + ")";
        rows.push(pre({
          key: k,
          className: "" + (deleted && 'deleted'),
          title: (m.format()) + " rev,linenum=" + k
        }, span({
          className: 'timestamp',
          style: {
            backgroundColor: color
          }
        }, m.format('HH:mm:ss')), span({
          className: "line"
        }, this.state.lineMap[k])));
      }
      return rows;
    };

    return App;

  })(React.Component);

  document.addEventListener('DOMContentLoaded', function() {
    return ReactDOM.render(React.createElement(App), document.querySelector('#root'));
  });

}).call(this);
